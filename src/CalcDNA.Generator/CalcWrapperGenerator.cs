using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;

namespace CalcDNA.Generator;

[Generator]
public class CalcWrapperGenerator : IIncrementalGenerator
{
    const string sStatic = "static";
    const string sPublic = "public";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // STEP 1: Filter - Find methods with [CalcFunction] in classes with [CalcAddIn]
        var methodDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => IsTargetMethod(node),
                transform: (ctx, _) => GetSemanticTarget(ctx))
            .Where(m => m is not null);

        // STEP 2: Output - Generate the wrapper code
        context.RegisterSourceOutput(methodDeclarations, (spc, method) => {
            if (method is null)
                return;

            var source = GenerateWrapperSource(method);
            spc.AddSource($"{method.ContainingType.Name}_{method.Name}_Wrapper.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static bool IsTargetMethod(SyntaxNode node)
    {
        // Method used for syntactic filter
        // Fast, lightweight check on the syntax tree

        // Check if node is a method with any attributes
        if (node is not MethodDeclarationSyntax method || method.AttributeLists.Count == 0)
            return false;

        // Check if containing class exists and has any attributes
        if (method.Parent is not ClassDeclarationSyntax classDeclaration || classDeclaration.AttributeLists.Count == 0)
            return false;

        // Check if method is public and static
        var modifiers = method.Modifiers;
        if (!modifiers.Any(m => m.ValueText == sPublic) || !modifiers.Any(m => m.ValueText == sStatic))
            return false;

        // Check if class is public and static
        var classModifiers = classDeclaration.Modifiers;
        if (!classModifiers.Any(m => m.ValueText == sPublic) || !classModifiers.Any(m => m.ValueText == sStatic))
            return false;

        return true;
    }

    private static IMethodSymbol? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        // Method used for semantic filter
        // More expensive, but provides full semantic information

        var method = (MethodDeclarationSyntax)context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(method) is not IMethodSymbol methodSymbol)
            return null;

        // Check if method has [CalcFunction] attribute
        var hasCalcFunction = methodSymbol.GetAttributes()
            .Any(attr => attr.AttributeClass?.Name == "CalcFunctionAttribute" ||
                        attr.AttributeClass?.Name == "CalcFunction");

        if (!hasCalcFunction)
            return null;

        // Check if containing class has [CalcAddIn] attribute
        var containingClass = methodSymbol.ContainingType;
        var hasCalcAddIn = containingClass.GetAttributes()
            .Any(attr => attr.AttributeClass?.Name == "CalcAddInAttribute" ||
                        attr.AttributeClass?.Name == "CalcAddIn");

        if (!hasCalcAddIn)
            return null;

        return methodSymbol;
    }

    private static string GenerateWrapperSource(IMethodSymbol method)
    {
        var className = method.ContainingType.Name;
        var methodName = method.Name;
        var namespaceName = method.ContainingNamespace.ToDisplayString();
        var returnType = WrapperTypeMapping.MapTypeToWrapper(method.ReturnType, false);

        var parameters = string.Join(", ", method.Parameters.Select(p =>
            $"{WrapperTypeMapping.MapTypeToWrapper(p.Type, WrapperTypeMapping.IsOptionalParameter(p))} {p.Name}"));

        // Build marshaling code and parameter list
        var marshalLines = new StringBuilder();
        var callArgs = new List<string>();

        foreach (var parameter in method.Parameters)
        {
            if (WrapperTypeMapping.NeedsMarshaling(parameter))
            {
                var marshaledName = $"marshaled_{parameter.Name}";
                marshalLines.AppendLine($"                var {marshaledName} = {WrapperTypeMapping.GetMarshalingCode(parameter)};");
                callArgs.Add(marshaledName);
            }
            else
            {
                callArgs.Add(parameter.Name);
            }
        }

        var callArgsList = string.Join(", ", callArgs);

        return $@"// <auto-generated/>
#nullable enable
using System;
using CalcDNA.Runtime;

namespace {namespaceName}
{{
    public partial class {className}
    {{
        public static {returnType} {methodName}_UNOWrapper({parameters})
        {{
            try
            {{
{marshalLines}                return {methodName}({callArgsList});
            }}
            catch (Exception ex)
            {{
                throw new Exception($""Error calling {methodName}: "" + ex.Message);
            }}
        }}
    }}
}}";
    }
}