using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CalcDNA.Generator;

[Generator]
public class CalcWrapperGenerator : IIncrementalGenerator
{
    private const string AttrCalcAddIn = "CalcAddIn";
    private const string AttrCalcAddInFull = "CalcAddInAttribute";
    private const string AttrCalcFunction = "CalcFunction";
    private const string AttrCalcFunctionFull = "CalcFunctionAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // STEP 1: Filter - Find [CalcAddIn] classes
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => IsTargetClass(node),
                transform: (ctx, _) => GetClassWrapperInfo(ctx))
            .Where(c => c is not null);

        // STEP 2: Output - Generate the wrapper code per class
        context.RegisterSourceOutput(classDeclarations, (spc, classInfo) => {
            if (classInfo is null)
                return;

            var source = GenerateClassWrapperSource(classInfo);
            spc.AddSource($"{classInfo.ClassName}_Wrappers.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static bool IsTargetClass(SyntaxNode node)
    {
        if (node is not ClassDeclarationSyntax classDecl || classDecl.AttributeLists.Count == 0)
            return false;

        var modifiers = classDecl.Modifiers;
        return modifiers.Any(m => m.ValueText == "public") &&
               modifiers.Any(m => m.ValueText == "static") &&
               modifiers.Any(m => m.ValueText == "partial");
    }

    private static ClassWrapperInfo? GetClassWrapperInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol classSymbol)
            return null;

        if (!classSymbol.GetAttributes().Any(a => 
            a.AttributeClass?.Name is AttrCalcAddIn or AttrCalcAddInFull))
            return null;

        var methods = classSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.IsStatic && m.DeclaredAccessibility == Accessibility.Public)
            .Where(m => m.GetAttributes().Any(a => 
                a.AttributeClass?.Name is AttrCalcFunction or AttrCalcFunctionFull))
            .ToList();

        if (methods.Count == 0)
            return null;

        return new ClassWrapperInfo(classSymbol, methods);
    }

    private static string GenerateClassWrapperSource(ClassWrapperInfo info)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using CalcDNA.Runtime;");
        sb.AppendLine();
        sb.AppendLine($"namespace {info.Namespace}");
        sb.AppendLine("{");
        sb.AppendLine($"    public partial class {info.ClassName}");
        sb.AppendLine("    {");

        foreach (var method in info.Methods)
        {
            GenerateMethodWrapper(sb, method);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateMethodWrapper(StringBuilder sb, IMethodSymbol method)
    {
        var methodName = method.Name;
        var returnType = WrapperTypeMapping.MapReturnTypeToWrapper(method.ReturnType);

        var parametersList = method.Parameters.Select(p =>
            $"{WrapperTypeMapping.MapTypeToWrapper(p.Type, WrapperTypeMapping.IsOptionalParameter(p))} {p.Name}");
        var parameters = string.Join(", ", parametersList);

        sb.AppendLine($"        public static {returnType} {methodName}_UNOWrapper({parameters})");
        sb.AppendLine("        {");
        sb.AppendLine("            try");
        sb.AppendLine("            {");

        var callArgs = new List<string>();
        foreach (var parameter in method.Parameters)
        {
            if (WrapperTypeMapping.NeedsMarshaling(parameter))
            {
                var marshaledName = $"marshaled_{parameter.Name}";
                sb.AppendLine($"                var {marshaledName} = {WrapperTypeMapping.GetMarshalingCode(parameter)};");
                callArgs.Add(marshaledName);
            }
            else
            {
                callArgs.Add(parameter.Name);
            }
        }

        var callCode = $"{methodName}({string.Join(", ", callArgs)})";
        var returnCode = WrapperTypeMapping.GetReturnMarshalingCode(method, callCode);
        
        sb.AppendLine($"                {returnCode}");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (Exception ex)");
        sb.AppendLine("            {");
        sb.AppendLine($"                throw new Exception($\"Error calling {methodName}: {{ex.Message}}\", ex);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
    }

    public class ClassWrapperInfo
    {
        public INamedTypeSymbol ClassSymbol { get; }
        public List<IMethodSymbol> Methods { get; }
        public string ClassName => ClassSymbol.Name;
        public string Namespace => ClassSymbol.ContainingNamespace.ToDisplayString();

        public ClassWrapperInfo(INamedTypeSymbol classSymbol, List<IMethodSymbol> methods)
        {
            ClassSymbol = classSymbol;
            Methods = methods;
        }
    }
}